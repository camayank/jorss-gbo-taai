"""
Unified Rule Engine.

A flexible, configuration-driven rule engine that supports:
- Loading rules from YAML configuration
- Dynamic rule evaluation
- AI-assisted rule generation
- Rule versioning and audit trails
- Performance optimization with caching
"""

from __future__ import annotations

import logging
import time
from dataclasses import dataclass, field
from datetime import datetime
from functools import lru_cache
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Set, Union

import yaml

from .rule_types import RuleCategory, RuleSeverity, RuleType

logger = logging.getLogger(__name__)

# Default rules directory
RULES_DIR = Path(__file__).parent / "definitions"


@dataclass
class Rule:
    """
    Represents a tax rule.

    Rules can be:
    - Loaded from YAML configuration
    - Created programmatically
    - Generated by AI
    """
    rule_id: str
    name: str
    description: str
    category: RuleCategory
    rule_type: RuleType
    severity: RuleSeverity = RuleSeverity.INFO

    # Rule parameters (loaded from config)
    threshold: Optional[float] = None
    limit: Optional[float] = None
    rate: Optional[float] = None
    phase_out_start: Optional[float] = None
    phase_out_end: Optional[float] = None

    # Filing status specific thresholds
    thresholds_by_status: Optional[Dict[str, float]] = None
    limits_by_status: Optional[Dict[str, float]] = None

    # IRS reference for compliance
    irs_reference: str = ""
    irs_form: str = ""
    irs_publication: str = ""

    # Rule metadata
    tax_year: int = 2025
    version: str = "1.0"
    effective_date: Optional[str] = None
    is_active: bool = True

    # Prerequisites and conflicts
    prerequisites: List[str] = field(default_factory=list)
    conflicts_with: List[str] = field(default_factory=list)

    # Evaluation function (optional, for complex rules)
    _evaluator: Optional[Callable] = field(default=None, repr=False)

    def get_threshold(self, filing_status: Optional[str] = None) -> Optional[float]:
        """Get threshold, optionally by filing status."""
        if self.thresholds_by_status and filing_status:
            return self.thresholds_by_status.get(
                filing_status,
                self.thresholds_by_status.get('single', self.threshold)
            )
        return self.threshold

    def get_limit(self, filing_status: Optional[str] = None) -> Optional[float]:
        """Get limit, optionally by filing status."""
        if self.limits_by_status and filing_status:
            return self.limits_by_status.get(
                filing_status,
                self.limits_by_status.get('single', self.limit)
            )
        return self.limit


@dataclass
class RuleContext:
    """
    Context for rule evaluation.

    Contains all data needed to evaluate a rule.
    """
    tax_year: int
    filing_status: str
    adjusted_gross_income: float = 0.0
    taxable_income: float = 0.0
    earned_income: float = 0.0

    # Taxpayer info
    age: int = 0
    is_blind: bool = False
    is_dependent: bool = False
    num_dependents: int = 0
    num_qualifying_children: int = 0

    # Income details
    wages: float = 0.0
    self_employment_income: float = 0.0
    investment_income: float = 0.0
    capital_gains: float = 0.0
    dividend_income: float = 0.0
    interest_income: float = 0.0

    # Deductions
    itemized_deductions: float = 0.0
    standard_deduction: float = 0.0
    retirement_contributions: float = 0.0
    hsa_contributions: float = 0.0

    # Credits
    child_tax_credit: float = 0.0
    education_credits: float = 0.0

    # Additional context
    state: Optional[str] = None
    has_health_coverage: bool = True
    is_covered_by_employer_plan: bool = False

    # Custom fields for rule-specific data
    custom_data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class RuleResult:
    """Result of a rule evaluation."""
    rule_id: str
    rule_name: str
    passed: bool
    severity: RuleSeverity

    # Result details
    message: str = ""
    value: Optional[float] = None
    expected_value: Optional[float] = None
    actual_value: Optional[float] = None

    # Recommendations
    recommendation: str = ""
    estimated_impact: Optional[float] = None

    # Metadata
    processing_time_ms: int = 0
    irs_reference: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'rule_id': self.rule_id,
            'rule_name': self.rule_name,
            'passed': self.passed,
            'severity': self.severity.value,
            'message': self.message,
            'value': self.value,
            'recommendation': self.recommendation,
            'estimated_impact': self.estimated_impact,
            'irs_reference': self.irs_reference,
        }


class RuleEngine:
    """
    Unified rule engine for tax calculations and validations.

    Features:
    - Load rules from YAML configuration
    - Evaluate rules against a context
    - Support for rule dependencies and conflicts
    - Caching for performance
    - Audit logging
    """

    def __init__(
        self,
        tax_year: int = 2025,
        rules_dir: Optional[Path] = None,
        config_loader: Optional[Any] = None
    ):
        """
        Initialize the rule engine.

        Args:
            tax_year: Tax year for rule evaluation
            rules_dir: Directory containing rule YAML files
            config_loader: Optional TaxConfigLoader for parameter lookups
        """
        self.tax_year = tax_year
        self.rules_dir = rules_dir or RULES_DIR
        self._config_loader = config_loader

        self._rules: Dict[str, Rule] = {}
        self._rules_by_category: Dict[RuleCategory, List[Rule]] = {}
        self._evaluation_cache: Dict[str, RuleResult] = {}
        self._evaluation_stats: Dict[str, Dict[str, Any]] = {}

        self._load_rules()

    def _load_rules(self) -> None:
        """Load rules from configuration files."""
        if not self.rules_dir.exists():
            logger.warning(f"Rules directory not found: {self.rules_dir}")
            self._load_default_rules()
            return

        # Load all YAML files in the rules directory
        for yaml_file in self.rules_dir.glob("*.yaml"):
            try:
                with open(yaml_file, 'r') as f:
                    rules_config = yaml.safe_load(f)

                if rules_config and 'rules' in rules_config:
                    for rule_data in rules_config['rules']:
                        rule = self._create_rule_from_config(rule_data)
                        if rule:
                            self._register_rule(rule)

                logger.info(f"Loaded rules from {yaml_file}")
            except Exception as e:
                logger.error(f"Error loading rules from {yaml_file}: {e}")

        # Also load default programmatic rules
        self._load_default_rules()

    def _create_rule_from_config(self, config: Dict[str, Any]) -> Optional[Rule]:
        """Create a Rule from configuration data."""
        try:
            return Rule(
                rule_id=config['rule_id'],
                name=config['name'],
                description=config.get('description', ''),
                category=RuleCategory(config.get('category', 'validation')),
                rule_type=RuleType(config.get('rule_type', 'validation')),
                severity=RuleSeverity(config.get('severity', 'info')),
                threshold=config.get('threshold'),
                limit=config.get('limit'),
                rate=config.get('rate'),
                phase_out_start=config.get('phase_out_start'),
                phase_out_end=config.get('phase_out_end'),
                thresholds_by_status=config.get('thresholds_by_status'),
                limits_by_status=config.get('limits_by_status'),
                irs_reference=config.get('irs_reference', ''),
                irs_form=config.get('irs_form', ''),
                irs_publication=config.get('irs_publication', ''),
                tax_year=config.get('tax_year', self.tax_year),
                version=config.get('version', '1.0'),
                is_active=config.get('is_active', True),
                prerequisites=config.get('prerequisites', []),
                conflicts_with=config.get('conflicts_with', []),
            )
        except Exception as e:
            logger.error(f"Error creating rule from config: {e}")
            return None

    def _load_default_rules(self) -> None:
        """Load default programmatic rules."""
        # Import and register default rules
        from .default_rules import get_default_rules
        for rule in get_default_rules(self.tax_year):
            self._register_rule(rule)

    def _register_rule(self, rule: Rule) -> None:
        """Register a rule in the engine."""
        self._rules[rule.rule_id] = rule

        # Index by category
        if rule.category not in self._rules_by_category:
            self._rules_by_category[rule.category] = []
        self._rules_by_category[rule.category].append(rule)

    def get_rule(self, rule_id: str) -> Optional[Rule]:
        """Get a rule by ID."""
        return self._rules.get(rule_id)

    def get_rules_by_category(self, category: RuleCategory) -> List[Rule]:
        """Get all rules in a category."""
        return self._rules_by_category.get(category, [])

    def get_all_rules(self) -> List[Rule]:
        """Get all registered rules."""
        return list(self._rules.values())

    def evaluate_rule(
        self,
        rule_id: str,
        context: RuleContext,
        use_cache: bool = True
    ) -> RuleResult:
        """
        Evaluate a single rule.

        Args:
            rule_id: ID of the rule to evaluate
            context: Context for evaluation
            use_cache: Whether to use cached results

        Returns:
            RuleResult with evaluation outcome
        """
        start_time = time.time()

        # Check cache
        cache_key = f"{rule_id}_{hash(str(context))}"
        if use_cache and cache_key in self._evaluation_cache:
            return self._evaluation_cache[cache_key]

        rule = self.get_rule(rule_id)
        if not rule:
            return RuleResult(
                rule_id=rule_id,
                rule_name="Unknown",
                passed=False,
                severity=RuleSeverity.ERROR,
                message=f"Rule not found: {rule_id}"
            )

        if not rule.is_active:
            return RuleResult(
                rule_id=rule_id,
                rule_name=rule.name,
                passed=True,
                severity=RuleSeverity.INFO,
                message="Rule is inactive"
            )

        # Evaluate the rule
        result = self._evaluate_rule_logic(rule, context)
        result.processing_time_ms = int((time.time() - start_time) * 1000)

        # Cache result
        if use_cache:
            self._evaluation_cache[cache_key] = result

        # Track stats
        self._track_evaluation(rule_id, result)

        return result

    def _evaluate_rule_logic(self, rule: Rule, context: RuleContext) -> RuleResult:
        """
        Evaluate the logic of a rule.

        This method handles different rule types with appropriate logic.
        """
        # If rule has a custom evaluator, use it
        if rule._evaluator:
            try:
                return rule._evaluator(rule, context)
            except Exception as e:
                logger.error(f"Error in custom evaluator for {rule.rule_id}: {e}")

        # Handle different rule types
        if rule.rule_type == RuleType.LIMIT:
            return self._evaluate_limit_rule(rule, context)
        elif rule.rule_type == RuleType.THRESHOLD:
            return self._evaluate_threshold_rule(rule, context)
        elif rule.rule_type == RuleType.PHASEOUT:
            return self._evaluate_phaseout_rule(rule, context)
        elif rule.rule_type == RuleType.ELIGIBILITY:
            return self._evaluate_eligibility_rule(rule, context)
        else:
            # Default: just check if active
            return RuleResult(
                rule_id=rule.rule_id,
                rule_name=rule.name,
                passed=True,
                severity=rule.severity,
                message="Rule evaluated (no specific logic)",
                irs_reference=rule.irs_reference,
            )

    def _evaluate_limit_rule(self, rule: Rule, context: RuleContext) -> RuleResult:
        """Evaluate a limit-type rule."""
        limit = rule.get_limit(context.filing_status)
        if limit is None:
            return RuleResult(
                rule_id=rule.rule_id,
                rule_name=rule.name,
                passed=True,
                severity=RuleSeverity.INFO,
                message="No limit defined"
            )

        # Get the value to check from context based on rule category
        value = self._get_value_for_category(rule.category, context)

        passed = value <= limit
        return RuleResult(
            rule_id=rule.rule_id,
            rule_name=rule.name,
            passed=passed,
            severity=rule.severity if not passed else RuleSeverity.INFO,
            message=f"Value ${value:,.2f} {'within' if passed else 'exceeds'} limit ${limit:,.2f}",
            value=value,
            expected_value=limit,
            actual_value=value,
            irs_reference=rule.irs_reference,
        )

    def _evaluate_threshold_rule(self, rule: Rule, context: RuleContext) -> RuleResult:
        """Evaluate a threshold-type rule."""
        threshold = rule.get_threshold(context.filing_status)
        if threshold is None:
            return RuleResult(
                rule_id=rule.rule_id,
                rule_name=rule.name,
                passed=True,
                severity=RuleSeverity.INFO,
                message="No threshold defined"
            )

        # Typically compare AGI to threshold
        value = context.adjusted_gross_income

        passed = value <= threshold
        return RuleResult(
            rule_id=rule.rule_id,
            rule_name=rule.name,
            passed=passed,
            severity=rule.severity if not passed else RuleSeverity.INFO,
            message=f"AGI ${value:,.2f} {'below' if passed else 'above'} threshold ${threshold:,.2f}",
            value=value,
            expected_value=threshold,
            irs_reference=rule.irs_reference,
        )

    def _evaluate_phaseout_rule(self, rule: Rule, context: RuleContext) -> RuleResult:
        """Evaluate a phase-out rule."""
        start = rule.phase_out_start
        end = rule.phase_out_end

        if start is None or end is None:
            return RuleResult(
                rule_id=rule.rule_id,
                rule_name=rule.name,
                passed=True,
                severity=RuleSeverity.INFO,
                message="Phaseout parameters not defined"
            )

        value = context.adjusted_gross_income

        if value <= start:
            phase_pct = 0.0
            message = "No phaseout applies"
        elif value >= end:
            phase_pct = 100.0
            message = "Fully phased out"
        else:
            phase_pct = ((value - start) / (end - start)) * 100
            message = f"Partially phased out ({phase_pct:.1f}%)"

        return RuleResult(
            rule_id=rule.rule_id,
            rule_name=rule.name,
            passed=phase_pct < 100,
            severity=rule.severity if phase_pct == 100 else RuleSeverity.INFO,
            message=message,
            value=phase_pct,
            metadata={'phase_pct': phase_pct, 'start': start, 'end': end},
            irs_reference=rule.irs_reference,
        )

    def _evaluate_eligibility_rule(self, rule: Rule, context: RuleContext) -> RuleResult:
        """Evaluate an eligibility rule."""
        # Default eligibility check based on threshold
        threshold = rule.get_threshold(context.filing_status)

        if threshold is None:
            # No threshold means always eligible
            return RuleResult(
                rule_id=rule.rule_id,
                rule_name=rule.name,
                passed=True,
                severity=RuleSeverity.INFO,
                message="Eligible (no restrictions)",
                irs_reference=rule.irs_reference,
            )

        passed = context.adjusted_gross_income <= threshold
        return RuleResult(
            rule_id=rule.rule_id,
            rule_name=rule.name,
            passed=passed,
            severity=rule.severity if not passed else RuleSeverity.INFO,
            message=f"{'Eligible' if passed else 'Not eligible'} - AGI ${context.adjusted_gross_income:,.2f} vs threshold ${threshold:,.2f}",
            irs_reference=rule.irs_reference,
        )

    def _get_value_for_category(self, category: RuleCategory, context: RuleContext) -> float:
        """Get the relevant value from context based on rule category."""
        category_value_map = {
            RuleCategory.INCOME: context.adjusted_gross_income,
            RuleCategory.DEDUCTION: context.itemized_deductions,
            RuleCategory.RETIREMENT: context.retirement_contributions,
            RuleCategory.INVESTMENT: context.investment_income,
            RuleCategory.SELF_EMPLOYMENT: context.self_employment_income,
            RuleCategory.HEALTHCARE: context.hsa_contributions,
            RuleCategory.NIIT: context.investment_income,
            RuleCategory.BUSINESS: context.self_employment_income,
            RuleCategory.CHARITABLE: context.itemized_deductions,
            RuleCategory.CREDIT: context.adjusted_gross_income,
            RuleCategory.EDUCATION: context.adjusted_gross_income,
            RuleCategory.ESTIMATED_TAX: context.adjusted_gross_income,
            RuleCategory.PENALTY: context.adjusted_gross_income,
        }
        value = category_value_map.get(category, context.adjusted_gross_income)
        # Ensure we never return None - default to 0.0
        return value if value is not None else 0.0

    def evaluate_all(
        self,
        context: RuleContext,
        categories: Optional[List[RuleCategory]] = None,
        severity_filter: Optional[RuleSeverity] = None
    ) -> List[RuleResult]:
        """
        Evaluate all applicable rules.

        Args:
            context: Context for evaluation
            categories: Optional list of categories to evaluate
            severity_filter: Only return results with this severity or higher

        Returns:
            List of RuleResult objects
        """
        results = []

        rules_to_evaluate = self._rules.values()

        if categories:
            rules_to_evaluate = [
                r for r in rules_to_evaluate
                if r.category in categories
            ]

        for rule in rules_to_evaluate:
            if not rule.is_active:
                continue

            result = self.evaluate_rule(rule.rule_id, context)

            if severity_filter:
                severity_order = [
                    RuleSeverity.SUGGESTION,
                    RuleSeverity.INFO,
                    RuleSeverity.WARNING,
                    RuleSeverity.ERROR,
                    RuleSeverity.CRITICAL
                ]
                if severity_order.index(result.severity) >= severity_order.index(severity_filter):
                    results.append(result)
            else:
                results.append(result)

        return results

    def _track_evaluation(self, rule_id: str, result: RuleResult) -> None:
        """Track evaluation statistics."""
        if rule_id not in self._evaluation_stats:
            self._evaluation_stats[rule_id] = {
                'total_evaluations': 0,
                'passed': 0,
                'failed': 0,
                'total_time_ms': 0,
            }

        stats = self._evaluation_stats[rule_id]
        stats['total_evaluations'] += 1
        stats['total_time_ms'] += result.processing_time_ms
        if result.passed:
            stats['passed'] += 1
        else:
            stats['failed'] += 1

    def get_stats(self) -> Dict[str, Dict[str, Any]]:
        """Get evaluation statistics."""
        return self._evaluation_stats.copy()

    def clear_cache(self) -> None:
        """Clear the evaluation cache."""
        self._evaluation_cache.clear()


# Global singleton
_rule_engine: Optional[RuleEngine] = None


def get_rule_engine(tax_year: int = 2025) -> RuleEngine:
    """Get the global rule engine instance."""
    global _rule_engine
    if _rule_engine is None or _rule_engine.tax_year != tax_year:
        _rule_engine = RuleEngine(tax_year=tax_year)
    return _rule_engine
