#!/usr/bin/env python3
"""
Supabase Setup Script

Automates the setup of the tax platform with Supabase PostgreSQL.

Usage:
    python scripts/setup_supabase.py

Or with connection string:
    python scripts/setup_supabase.py --url "postgresql://postgres:PASSWORD@db.PROJECT.supabase.co:5432/postgres"
"""

import argparse
import os
import secrets
import subprocess
import sys
from pathlib import Path
from urllib.parse import urlparse, parse_qs


# Colors for terminal output
class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    BOLD = '\033[1m'
    END = '\033[0m'


def print_header(text: str):
    print(f"\n{Colors.BOLD}{Colors.BLUE}{'='*60}{Colors.END}")
    print(f"{Colors.BOLD}{Colors.BLUE}{text}{Colors.END}")
    print(f"{Colors.BOLD}{Colors.BLUE}{'='*60}{Colors.END}\n")


def print_success(text: str):
    print(f"{Colors.GREEN}✓ {text}{Colors.END}")


def print_warning(text: str):
    print(f"{Colors.YELLOW}⚠ {text}{Colors.END}")


def print_error(text: str):
    print(f"{Colors.RED}✗ {text}{Colors.END}")


def print_info(text: str):
    print(f"{Colors.BLUE}ℹ {text}{Colors.END}")


def generate_secret(length: int = 32) -> str:
    """Generate a secure random secret."""
    return secrets.token_hex(length)


def parse_supabase_url(url: str) -> dict:
    """Parse Supabase connection URL into components."""
    parsed = urlparse(url)

    return {
        'host': parsed.hostname,
        'port': parsed.port or 5432,
        'name': parsed.path.lstrip('/') or 'postgres',
        'user': parsed.username or 'postgres',
        'password': parsed.password or '',
    }


def prompt_for_credentials() -> dict:
    """Interactively prompt for Supabase credentials."""
    print_info("Enter your Supabase connection details.")
    print_info("Find these in: Supabase Dashboard → Settings → Database\n")

    # Option to paste full URL
    print("You can either:")
    print("  1. Paste the full connection string (URI)")
    print("  2. Enter details individually\n")

    url = input("Connection string (or press Enter to skip): ").strip()

    if url:
        try:
            return parse_supabase_url(url)
        except Exception as e:
            print_error(f"Failed to parse URL: {e}")
            print_info("Falling back to manual entry...\n")

    # Manual entry
    project_ref = input("Project reference (e.g., abcdefghijk): ").strip()
    password = input("Database password: ").strip()

    return {
        'host': f"db.{project_ref}.supabase.co",
        'port': 5432,
        'name': 'postgres',
        'user': 'postgres',
        'password': password,
    }


def create_env_file(db_config: dict, env_path: Path) -> None:
    """Create .env file with all required configuration."""

    # Generate all security keys
    secrets_config = {
        'APP_SECRET_KEY': generate_secret(32),
        'JWT_SECRET': generate_secret(32),
        'AUTH_SECRET_KEY': generate_secret(32),
        'PASSWORD_SALT': generate_secret(16),
        'ENCRYPTION_MASTER_KEY': generate_secret(32),
        'CSRF_SECRET_KEY': generate_secret(32),
    }

    env_content = f"""# =============================================================================
# Supabase Database Configuration
# Generated by setup_supabase.py
# =============================================================================

# Database - Supabase PostgreSQL
DB_DRIVER=postgresql+asyncpg
DB_HOST={db_config['host']}
DB_PORT={db_config['port']}
DB_NAME={db_config['name']}
DB_USER={db_config['user']}
DB_PASSWORD={db_config['password']}
DB_SSL_MODE=require

# Connection pool settings (optimized for Supabase)
DB_POOL_SIZE=10
DB_MAX_OVERFLOW=20
DB_POOL_TIMEOUT=30

# =============================================================================
# Security Keys (auto-generated - keep these secret!)
# =============================================================================

APP_SECRET_KEY={secrets_config['APP_SECRET_KEY']}
JWT_SECRET={secrets_config['JWT_SECRET']}
AUTH_SECRET_KEY={secrets_config['AUTH_SECRET_KEY']}
PASSWORD_SALT={secrets_config['PASSWORD_SALT']}
ENCRYPTION_MASTER_KEY={secrets_config['ENCRYPTION_MASTER_KEY']}
CSRF_SECRET_KEY={secrets_config['CSRF_SECRET_KEY']}

# =============================================================================
# Application Settings
# =============================================================================

APP_ENVIRONMENT=development
APP_DEBUG=true
APP_NAME=Tax Platform
APP_VERSION=1.0.0

# API settings
APP_API_HOST=0.0.0.0
APP_API_PORT=8000

# CORS (add your frontend URL in production)
# APP_CORS_ORIGINS=["http://localhost:3000","http://localhost:8000"]

# =============================================================================
# Optional: Redis (for caching - can use Supabase Edge Functions cache instead)
# =============================================================================

# REDIS_HOST=localhost
# REDIS_PORT=6379

# =============================================================================
# Optional: Email Configuration
# =============================================================================

# SendGrid (recommended)
# SENDGRID_API_KEY=your-sendgrid-api-key
# SENDGRID_FROM_EMAIL=noreply@yourdomain.com

# Or SMTP
# SMTP_HOST=smtp.gmail.com
# SMTP_PORT=587
# SMTP_USERNAME=your-email@gmail.com
# SMTP_PASSWORD=your-app-password
"""

    # Check if .env exists
    if env_path.exists():
        backup_path = env_path.with_suffix('.env.backup')
        print_warning(f".env already exists. Backing up to {backup_path}")
        env_path.rename(backup_path)

    env_path.write_text(env_content)
    print_success(f"Created {env_path}")


def install_dependencies() -> bool:
    """Install required PostgreSQL dependencies."""
    print_info("Installing PostgreSQL dependencies...")

    try:
        subprocess.run(
            [sys.executable, "-m", "pip", "install", "asyncpg", "psycopg2-binary"],
            check=True,
            capture_output=True,
            text=True
        )
        print_success("Installed asyncpg and psycopg2-binary")
        return True
    except subprocess.CalledProcessError as e:
        print_error(f"Failed to install dependencies: {e.stderr}")
        return False


def run_migrations(project_root: Path) -> bool:
    """Run Alembic migrations."""
    print_info("Running database migrations...")

    alembic_dir = project_root / "src" / "database"

    try:
        result = subprocess.run(
            ["alembic", "upgrade", "head"],
            cwd=alembic_dir,
            check=True,
            capture_output=True,
            text=True,
            env={**os.environ, "PYTHONPATH": str(project_root / "src")}
        )
        print_success("Migrations completed successfully")
        if result.stdout:
            print(result.stdout)
        return True
    except subprocess.CalledProcessError as e:
        print_error(f"Migration failed: {e.stderr}")
        return False
    except FileNotFoundError:
        print_error("Alembic not found. Install with: pip install alembic")
        return False


def verify_connection(project_root: Path) -> bool:
    """Verify database connection."""
    print_info("Verifying database connection...")

    test_script = """
import asyncio
import sys
sys.path.insert(0, 'src')

from config.database import get_database_settings

async def test_connection():
    settings = get_database_settings()
    print(f"  Driver: {settings.driver}")
    print(f"  Host: {settings.host}")
    print(f"  Database: {settings.name}")
    print(f"  SSL Mode: {settings.ssl_mode}")

    # Test actual connection
    try:
        import asyncpg
        conn = await asyncpg.connect(
            host=settings.host,
            port=settings.port,
            user=settings.user,
            password=settings.password,
            database=settings.name,
            ssl='require'
        )
        version = await conn.fetchval('SELECT version()')
        print(f"  PostgreSQL: {version[:50]}...")
        await conn.close()
        return True
    except Exception as e:
        print(f"  Connection error: {e}")
        return False

result = asyncio.run(test_connection())
sys.exit(0 if result else 1)
"""

    try:
        result = subprocess.run(
            [sys.executable, "-c", test_script],
            cwd=project_root,
            check=True,
            capture_output=True,
            text=True
        )
        print(result.stdout)
        print_success("Database connection verified")
        return True
    except subprocess.CalledProcessError as e:
        print(e.stdout)
        print_error(f"Connection verification failed")
        if e.stderr:
            print(e.stderr)
        return False


def print_next_steps():
    """Print next steps for the user."""
    print_header("Setup Complete!")

    print(f"""
{Colors.GREEN}Your Supabase database is configured and ready!{Colors.END}

{Colors.BOLD}Next Steps:{Colors.END}

1. Start the development server:
   {Colors.BLUE}uvicorn src.web.app:app --reload --port 8000{Colors.END}

2. Access the API:
   {Colors.BLUE}http://localhost:8000{Colors.END}
   {Colors.BLUE}http://localhost:8000/docs{Colors.END} (Swagger UI)

3. View your data in Supabase:
   {Colors.BLUE}https://app.supabase.com/project/YOUR_PROJECT/editor{Colors.END}

{Colors.BOLD}Useful Commands:{Colors.END}

  Run tests:
    {Colors.BLUE}python -m pytest{Colors.END}

  Check migration status:
    {Colors.BLUE}cd src/database && alembic current{Colors.END}

  Create new migration:
    {Colors.BLUE}cd src/database && alembic revision --autogenerate -m "description"{Colors.END}

{Colors.YELLOW}Security Note:{Colors.END}
  - Keep your .env file secure and never commit it to git
  - The generated secrets are unique to this installation
  - For production, use Supabase connection pooling (port 6543)
""")


def main():
    parser = argparse.ArgumentParser(
        description="Set up the tax platform with Supabase PostgreSQL"
    )
    parser.add_argument(
        "--url",
        help="Supabase connection string (URI format)"
    )
    parser.add_argument(
        "--skip-migrations",
        action="store_true",
        help="Skip running database migrations"
    )
    parser.add_argument(
        "--skip-deps",
        action="store_true",
        help="Skip installing dependencies"
    )

    args = parser.parse_args()

    # Determine project root
    script_path = Path(__file__).resolve()
    project_root = script_path.parent.parent
    env_path = project_root / ".env"

    print_header("Supabase Setup for Tax Platform")

    # Step 1: Get credentials
    print(f"{Colors.BOLD}Step 1: Database Credentials{Colors.END}")
    if args.url:
        db_config = parse_supabase_url(args.url)
        print_success(f"Using provided connection string")
    else:
        db_config = prompt_for_credentials()

    print_success(f"Host: {db_config['host']}")
    print_success(f"Database: {db_config['name']}")

    # Step 2: Create .env file
    print(f"\n{Colors.BOLD}Step 2: Creating Configuration{Colors.END}")
    create_env_file(db_config, env_path)

    # Step 3: Install dependencies
    if not args.skip_deps:
        print(f"\n{Colors.BOLD}Step 3: Installing Dependencies{Colors.END}")
        if not install_dependencies():
            print_warning("Dependency installation failed. You may need to install manually.")

    # Step 4: Verify connection
    print(f"\n{Colors.BOLD}Step 4: Verifying Connection{Colors.END}")
    connection_ok = verify_connection(project_root)

    # Step 5: Run migrations
    if not args.skip_migrations and connection_ok:
        print(f"\n{Colors.BOLD}Step 5: Running Migrations{Colors.END}")
        run_migrations(project_root)
    elif not connection_ok:
        print_warning("Skipping migrations due to connection issues")

    # Done!
    print_next_steps()


if __name__ == "__main__":
    main()
